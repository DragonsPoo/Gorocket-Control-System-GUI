<img width="2879" height="1707" alt="image" src="https://github.com/user-attachments/assets/c90cc718-bac5-4cd8-a8b0-35ad40c5e9c1" />

# 로켓 엔진 테스트용 제어 및 모니터링 GUI

## 🚀 소개

이 프로젝트는 로켓 엔진 테스트를 더 쉽고 안전하게 진행할 수 있도록 돕는 데스크톱 GUI 애플리케이션입니다. 복잡한 명령어 없이 마우스 클릭만으로 센서 데이터를 확인하고 밸브를 제어할 수 있어, 로켓 엔진 테스트 스탠드를 처음 다루는 분들도 직관적으로 사용할 수 있습니다.

이 애플리케이션은 **Electron**을 기반으로 만들어져 Windows, macOS, Linux 등 다양한 운영체제에서 동일하게 동작합니다. 사용자 인터페이스(UI)는 **Next.js**와 **React**를 사용해 만들어져 빠르고 현대적인 웹 기술을 데스크톱 환경에서 그대로 경험할 수 있습니다.

### ✨ 주요 기술 스택

- **Electron**: 웹 기술(HTML, CSS, JavaScript)로 데스크톱 앱을 만들 수 있게 해주는 프레임워크입니다.
- **Next.js / React**: 사용자 인터페이스를 만들기 위한 JavaScript 라이브러리입니다.
- **TypeScript**: 코드의 안정성과 가독성을 높여주는 JavaScript의 확장 언어입니다.
- **Tailwind CSS & shadcn/ui**: 세련되고 일관된 디자인을 쉽게 적용할 수 있게 돕는 UI 라이브러리입니다.
- **Recharts**: 센서 데이터를 실시간 그래프로 아름답게 시각화하는 라이브러리입니다.
- **Node-Serialport**: PC와 아두이노(Arduino) 같은 하드웨어 간의 시리얼 통신을 가능하게 합니다.
- **Arduino**: 실제 센서를 읽고 밸브를 움직이는 역할을 하는 마이크로컨트롤러 보드입니다.

---

## 🎯 주요 기능

### 1. 실시간 센서 모니터링
- **직관적인 데이터 확인**: 4개의 압력 센서(PT), 2개의 유량 센서(Flow), 2개의 열전대(TC)에서 들어오는 데이터를 실시간으로 보여줍니다.
- **시각적 그래프**: 모든 센서 데이터는 시간에 따른 변화를 쉽게 파악할 수 있도록 시계열 그래프로 표시됩니다.
- **한눈에 보는 대시보드**: 현재 값을 큰 숫자로 표시하여 중요한 정보를 놓치지 않도록 돕습니다.

### 2. 간편한 밸브 제어
- **원격 밸브 조작**: 총 7개의 서보 밸브를 버튼 클릭만으로 개별적으로 열고 닫을 수 있습니다.
- **정확한 상태 피드백**: 각 밸브에 달린 2개의 리미트 스위치가 현재 밸브가 완전히 열렸는지, 아니면 닫혔는지를 감지하여 화면에 명확하게 표시해 줍니다.

### 3. 자동 테스트 시퀀스 실행
- **원클릭 테스트**: 퍼지(Purge), 점화(Ignition), 메인 연소(Main Combustion) 등 미리 설정된 복잡한 테스트 단계를 버튼 하나로 순차적으로 실행합니다.
- **진행 상황 확인**: 각 단계의 실행 과정과 결과는 터미널 형태의 패널에 순서대로 기록되어 모든 과정을 쉽게 추적할 수 있습니다.
- **사용자 맞춤 시퀀스**: 테스트 시퀀스의 각 단계(밸브 개폐, 대기 시간 등)는 코드 내에서 쉽게 수정할 수 있습니다. 자세한 내용은 [자동 테스트 시퀀스 조정](#-자동-테스트-시퀀스-조정) 섹션을 참고하세요.

### 4. 데이터 로깅 및 저장
- **모든 데이터 기록**: 테스트 중 측정되는 모든 센서 데이터는 타임스탬프와 함께 PC에 CSV 파일로 자동 저장됩니다.
- **손쉬운 제어**: GUI에서 '로깅 시작'과 '로깅 중지' 버튼으로 데이터 기록 시점을 자유롭게 제어할 수 있습니다.
- **분석용 데이터 확보**: 저장된 파일은 Excel이나 Python 등으로 열어 테스트 결과를 정밀하게 분석하고 보고서를 작성하는 데 활용할 수 있습니다.

### 5. 안정적인 하드웨어 연결
- **자동 포트 검색**: PC에 연결된 장치 중 통신 가능한 시리얼 포트를 자동으로 찾아 목록으로 보여줍니다.
- **명확한 연결 상태**: 사용자가 목록에서 아두이노 보드를 선택하면, 연결 성공 여부가 UI에 명확히 표시되어 통신 상태를 쉽게 알 수 있습니다.

---

## 🏗️ 시스템 아키텍처

이 애플리케이션은 크게 세 부분으로 나뉘어 동작합니다.

```
+--------------------------------+
|       UI Layer (Frontend)      |  <-- 사용자가 보는 화면 (in src/)
|  (Next.js / React / TypeScript)|
+--------------------------------+
             ^      | IPC (내부 통신)
             |      v
+--------------------------------+
|  Main Process Layer (Backend)  |  <-- 앱의 핵심 로직 (in main/ and main.ts)
|   (Electron / Node.js / TS)    |
+--------------------------------+
             ^      | Serial (직렬 통신)
             |      v
+--------------------------------+
|      Hardware Layer (Device)   |  <-- 실제 장치 (in arduino_mega_code/)
|         (Arduino Mega)         |
+--------------------------------+
```

1.  **UI Layer (Frontend)**
    - 사용자가 직접 보고 상호작용하는 화면 부분입니다. (`src` 폴더)
    - Next.js와 React를 기반으로 만들어졌으며, `preload.ts` 파일을 통해 아래의 Main Process와 안전하게 데이터를 주고받습니다.

2.  **Main Process Layer (Backend)**
    - 눈에 보이지 않는 곳에서 앱의 핵심 기능을 담당하는 부분입니다. (`main.ts`와 `main` 폴더)
    - Electron의 메인 프로세스로, 시리얼 포트 연결, 데이터 파일 저장, 설정 관리 등 중요한 작업을 처리합니다.
    - 아두이노 보드와 직접 통신하며 명령을 보내고 데이터를 받습니다.

3.  **Hardware Layer (Device)**
    - 실제 로켓 테스트 스탠드에 연결된 아두이노 보드입니다. (`arduino_mega_code` 폴더)
    - 센서 값을 읽고, 서보 모터를 제어하는 펌웨어 코드가 이 보드 위에서 실행됩니다.
    - Main Process로부터 받은 명령을 수행하고, 측정한 데이터를 PC로 보냅니다.

---

## 📂 파일 구조

프로젝트 폴더는 다음과 같이 구성되어 있습니다.

```
.
├── arduino_mega_code/     # 아두이노 보드에 업로드할 펌웨어 코드
├── main/                  # Electron 메인 프로세스에서 사용할 모듈 (e.g., 시리얼, 로깅)
├── src/                   # Next.js/React로 작성된 프론트엔드 UI 코드
│   ├── app/               # 웹 페이지와 레이아웃 정의
│   ├── components/        # 버튼, 차트 등 재사용 가능한 UI 조각들
│   ├── hooks/             # 데이터 관리 등 반복되는 로직을 모아둔 훅
│   ├── lib/               # 프론트엔드 전용 유틸리티 함수
│   └── sequences.json     # 자동 테스트 시퀀스 설정 파일
├── shared/                # 프론트엔드와 백엔드에서 공유하는 타입 및 유틸
│   ├── types/             # 전역 타입 정의
│   └── utils/             # 공용 유틸리티 함수
├── docs/                  # 프로젝트 관련 참고 문서나 설계 자료
├── main.ts                # Electron 앱이 처음 시작될 때 실행되는 메인 프로세스 진입점
├── preload.ts             # UI(Renderer)와 메인 프로세스를 안전하게 연결하는 다리 역할
├── config.json            # 시리얼 통신 속도, 밸브 이름 등 앱의 설정을 담는 파일
└── package.json           # 프로젝트에 필요한 라이브러리 목록과 실행 명령어 정의
```

---

## 🛠️ 개발 환경 준비

이 프로젝트를 직접 수정하고 실행해 보려면 다음 단계를 따라주세요.

### 1. 필수 소프트웨어 설치
- **[Node.js](https://nodejs.org/) (버전 18 이상)**: JavaScript 실행 환경입니다. `npm`이 함께 설치됩니다.
- **[Arduino IDE](https://www.arduino.cc/en/software)**: 아두이노 보드에 펌웨어를 업로드할 때 필요합니다.
- **Git** (선택 사항): 코드 버전을 관리하고 GitHub에서 프로젝트를 내려받을 때 편리합니다.

설치가 완료되면 터미널(명령 프롬프트 또는 PowerShell)에서 아래 명령어로 설치를 확인합니다.
```bash
node -v
npm -v
```

### 2. 프로젝트 내려받기 및 의존성 설치
터미널을 열고 아래 명령어를 순서대로 입력합니다.
```bash
# 1. GitHub에서 프로젝트를 복제합니다.
git clone https://github.com/your-username/Gorocket-Control-System-GUI.git

# 2. 프로젝트 폴더로 이동합니다.
cd Gorocket-Control-System-GUI

# 3. package.json에 기록된 모든 라이브러리를 자동으로 설치합니다.
npm install
```

### 3. 네이티브 모듈 재빌드
이 프로젝트는 하드웨어 통신을 위해 `serialport`라는 라이브러리를 사용합니다. 이 라이브러리는 C++로 만들어진 부분이 있어, 현재 설치된 Electron 버전에 맞게 다시 컴파일(재빌드)해야 합니다.
```bash
npm run rebuild
```
> **⚠️ Windows 사용자 주의**: 이 과정에서 오류가 발생한다면, C++ 코드를 컴파일하는 데 필요한 도구가 설치되지 않았을 가능성이 높습니다. 터미널을 **관리자 권한으로** 실행한 뒤, 아래 명령어를 실행하여 빌드 도구를 먼저 설치하고 다시 시도해 보세요.
> `npm install --global windows-build-tools`

### 4. Arduino 펌웨어 업로드
1.  PC에 Arduino Mega 보드를 USB 케이블로 연결합니다.
2.  Arduino IDE를 실행합니다.
3.  **파일 > 열기**를 선택하여 이 프로젝트의 `arduino_mega_code/arduino_mega_code.ino` 파일을 엽니다.
4.  **툴 > 보드** 메뉴에서 `Arduino Mega or Mega 2560`을 선택합니다.
5.  **툴 > 포트** 메뉴에서 Arduino가 연결된 COM 포트를 선택합니다. (e.g., `COM3`)
6.  IDE의 **업로드** 버튼(오른쪽 화살표 아이콘)을 눌러 펌웨어를 보드에 탑재합니다.

---

## ▶️ 실행 방법

### 개발 모드 (Development)
코드를 수정하면서 바로바로 변경 사항을 확인하고 싶을 때 사용합니다.
```bash
npm run dev
```
이 명령어를 실행하면 UI 개발 서버와 Electron 앱이 동시에 실행되며, 코드를 저장할 때마다 앱이 자동으로 새로고침됩니다.

### 프로덕션 빌드 (Production)
다른 사람에게 배포할 수 있는 설치 파일(.exe 등)을 만들 때 사용합니다.
```bash
npm run build
```
> **⚠️ 경고**: 현재 프로덕션 빌드(`npm run build`)는 불안정하며 정상적으로 동작하지 않을 수 있습니다. 배포용으로 사용하기보다는 개발 모드(`npm run dev`)로 실행하는 것을 권장합니다.

---

## 🔬 자동 테스트 시퀀스 조정

자동 테스트 시퀀스는 미리 정해진 순서에 따라 밸브를 제어하고 대기하는 작업들의 모음입니다. 이 시퀀스는 사용자의 필요에 맞게 직접 수정할 수 있습니다.

시퀀스 로직은 `src/hooks/useSequenceManager.ts`와 `src/sequences.json`에 정의되어 있습니다. JSON 파일에 시퀀스 단계를 추가하거나 수정하면 UI에도 자동으로 반영됩니다.

`src/sequences.json` 예시는 다음과 같습니다.

```json
{
  "Ignition Sequence": [
    {
      "message": "Opening valves 1 and 2",
      "delay": 500,
      "commands": ["V,1,O", "V,2,O"]
    }
  ],
  "Emergency Shutdown": [
    {
      "message": "Emergency shutdown: close all valves",
      "delay": 100,
      "commands": ["V,0,C", "V,1,C", "V,2,C", "V,3,C", "V,4,C", "V,5,C", "V,6,C"]
    }
  ]
}
```

### 조정 방법

- **새 시퀀스 추가**: `src/sequences.json`에 새 키와 단계를 추가합니다. 각 단계는 `message`(로그 메시지), `delay`(밀리초), `commands`(시리얼로 보낼 명령 문자열 배열)로 구성됩니다.
- **명령 수정**: `commands` 배열에 `"V,서보번호,O"` 또는 `"V,서보번호,C"`처럼 아두이노에 보낼 제어 명령을 원하는 대로 작성합니다.
- **UI 커스터마이즈(선택 사항)**: 시퀀스 버튼의 아이콘이나 색을 바꾸고 싶다면 `src/components/dashboard/sequence-panel.tsx`의 `sequenceMeta` 객체를 수정하세요.

---

## ⚙️ 설정 파일 (`config.json`)

앱의 세부 동작은 `config.json` 파일을 수정하여 변경할 수 있습니다.

```json
{
  "serial": {
    "baudRate": 115200
  },
  "maxChartDataPoints": 100,
  "pressureLimit": 850,
  "initialValves": [
    { "id": 1, "name": "Ethanol Main", "state": "CLOSED" }
  ],
  "valveMappings": {
    "Ethanol Main": { "servoIndex": 0 }
  }
}
```

- `serial.baudRate`: 아두이노와 통신할 때의 속도입니다. 펌웨어 코드의 `Serial.begin()`에 설정된 값과 반드시 일치해야 합니다.
- `maxChartDataPoints`: 실시간 차트에 표시될 데이터 포인트의 최대 개수입니다. 이 값을 넘어가면 가장 오래된 데이터부터 사라집니다.
- `pressureLimit`: 특정 압력 센서 값이 이 기준(PSI 단위)을 초과하면 UI에 경고를 표시합니다.
- `initialValves`: 앱이 시작될 때 화면에 표시될 밸브의 이름과 초기 상태 목록입니다.
- `valveMappings`: UI의 밸브 이름(e.g., "Ethanol Main")과 아두이노 펌웨어에서 실제로 제어하는 서보 모터의 번호(인덱스)를 연결해주는 중요한 설정입니다.

---

## 🤔 문제 해결 팁

- **`npm run rebuild` 실행 중 에러가 발생해요.**
  - 대부분 C++ 컴파일 도구가 없어서 발생하는 문제입니다. [개발 환경 준비](#3-네이티브-모듈-재빌드)의 Windows 사용자 주의사항을 참고하여 빌드 도구를 설치해 보세요.

- **앱에서 시리얼 포트가 보이지 않아요.**
  - 아두이노 보드가 PC에 제대로 연결되었는지 USB 케이블을 확인해 보세요.
  - 장치 관리자(Windows) 또는 시스템 정보(macOS)에서 보드가 정상적으로 인식되었는지 확인하고, 필요하다면 드라이버를 설치하세요.

---

이 문서는 프로젝트의 기본적인 소개와 사용법을 안내합니다. 프로젝트를 사용하시면서 발견한 버그나 개선 아이디어가 있다면 언제든지 GitHub 이슈로 등록해 주세요!
