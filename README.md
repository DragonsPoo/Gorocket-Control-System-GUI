<img width="2879" height="1700" alt="image" src="https://github.com/user-attachments/assets/ff2199ca-45b7-43f5-a146-2680b53c5f0f" />

# GOROCKET Control Suite

`GOROCKET Control Suite`는 고로켓 팀이 액체 로켓 엔진 시험대를 보다 안전하고 효율적으로 운용하기 위해 만든 **데스크톱 제어 애플리케이션**입니다. USB 케이블을 이용한 **유선 시리얼 통신**만으로 센서 데이터를 수집하고 밸브를 조작하며, 점화·퍼지와 같은 자동 시퀀스를 실행할 수 있습니다. 네트워크 기능이나 사용자 인증 모듈이 포함되어 있지 않으므로, **개인 PC나 연구실 환경에서만 사용**해야 합니다.

## ⚠️ 안전 안내

- 실제 추진제를 사용하기 전에 반드시 모의 장비로 충분히 연습하세요.
- 잘못된 설정이나 부주의한 조작은 하드웨어 파손 및 안전사고로 이어질 수 있습니다.
- 본 프로젝트의 사용으로 발생하는 모든 책임은 사용자에게 있습니다.

---

## 목차

1. [프로젝트 소개](#프로젝트-소개)
2. [빠른 시작](#빠른-시작)
3. [시스템 요구 사항](#시스템-요구-사항)
4. [설치와 실행](#설치와-실행)
5. [디렉터리 구조](#디렉터리-구조)
6. [GUI 코드 흐름 이해하기](#gui-코드-흐름-이해하기)
7. [설정 파일 상세 (`config.json`)](#설정-파일-상세-configjson)
8. [시퀀스 사용자 정의와 동작 방식](#시퀀스-사용자-정의와-동작-방식)
9. [시리얼 통신 프로토콜](#시리얼-통신-프로토콜)
10. [데이터 로깅](#데이터-로깅)
11. [UI 사용 방법](#ui-사용-방법)
12. [품질 검사와 빌드](#품질-검사와-빌드)
13. [문제 해결](#문제-해결)
14. [자주 묻는 질문](#자주-묻는-질문)
15. [참고 문서 및 라이선스](#참고-문서-및-라이선스)

---

## 프로젝트 소개

이 프로그램은 **센서 모니터링·밸브 제어·자동 시퀀스 실행**을 한 화면에서 수행할 수 있도록 설계되었습니다. 주요 특징은 다음과 같습니다.

- Electron + Next.js 기반으로 Windows, macOS, Linux 모두에서 동일한 인터페이스 제공
- 최대 4개의 압력 센서, 2개의 유량 센서, 1개의 열전대 등 다양한 계측값 표시
- 점화, 퍼지, 비상 정지(E‑Stop) 등 자동 시퀀스를 시간 순서대로 실행
- 수집된 데이터를 CSV 형식으로 저장하여 후처리 가능

하드웨어 제어 로직은 `arduino_mega_code` 폴더의 펌웨어에 구현되어 있고, 이 프로젝트는 **사용자 인터페이스와 시리얼 통신**을 담당합니다.

---

## 빠른 시작

아래 순서를 따라 하면 바로 애플리케이션을 실행해 볼 수 있습니다.

1. [시스템 요구 사항](#시스템-요구-사항)을 만족하는지 확인합니다. 터미널에서 `node -v`와 `npm -v`로 버전을 확인하세요.
2. 저장소를 클론합니다.
   ```bash
   git clone <레포지토리 URL>
   cd Gorocket-Control-System-GUI
   ```
3. 의존성을 설치합니다.
   ```bash
   npm install
   ```
4. 개발 모드로 실행합니다.
   ```bash
   npm run dev
   ```
   9002번 포트에서 Next.js 개발 서버가 실행되고 Electron 창이 자동으로 열립니다.
5. 상단 메뉴에서 시리얼 포트를 선택한 뒤 `Connect` 버튼을 눌러 하드웨어와 연결합니다.
6. 센서 값과 밸브 상태가 정상적으로 표시되는지 확인하고 실험을 진행합니다.

각 단계에 대한 자세한 설명은 아래를 참고하세요.

---

## 시스템 요구 사항

| 구분 | 권장 사양 |
| --- | --- |
| **운영 체제** | Windows 10 이상, macOS 13 이상, 최신 Linux 배포판 |
| **Node.js** | 20.x 이상 |
| **npm** | 10.x 이상 (Node 설치 시 자동 포함) |
| **하드웨어** | 시리얼 통신이 가능한 USB 포트 및 케이블 |

> **Tip**: Node.js와 npm이 설치되어 있지 않다면 [Node.js 공식 사이트](https://nodejs.org/)에서 LTS 버전을 내려받아 설치하세요.

---

## 설치와 실행

### 1. 저장소 클론

Git이 설치되어 있지 않다면 [Git 공식 페이지](https://git-scm.com/)에서 설치한 뒤 아래 명령을 실행합니다.

```bash
git clone <레포지토리 URL>
cd Gorocket-Control-System-GUI
```

### 2. 의존성 설치

```bash
npm install
```

- 네트워크 환경에 따라 시간이 걸릴 수 있습니다.
- 권한 문제로 실패한다면 Windows에서는 관리자 권한, macOS/Linux에서는 `sudo`를 사용해 다시 실행합니다.

### 3. 개발 모드 실행

```bash
npm run dev
```

- 9002번 포트에서 Next.js 개발 서버가 실행되고 Electron이 새 창을 띄웁니다.
- 콘솔에 오류가 보이면 `node_modules`를 삭제하고 다시 설치해 보세요.

### 4. 프로덕션 빌드 생성

```bash
npm run build
```

- `dist/` 폴더에 배포용 실행 파일과 리소스가 생성됩니다.
- 다른 PC에서 실행하려면 `config.json`도 함께 복사해야 합니다.

### 5. 빌드된 앱 실행

```bash
electron .   # 또는 dist 폴더의 실행 파일을 직접 실행
```

- 첫 실행 시 Windows SmartScreen이나 macOS 보안 경고가 나타날 수 있습니다. 개발 환경에서는 무시하고 진행하면 됩니다.

---

## 디렉터리 구조

소스 코드의 전체 구조와 각 폴더의 역할은 다음과 같습니다.

```
.
├── main.ts               # Electron 메인 프로세스: 앱 창 생성 및 시리얼 포트 제어
├── preload.ts            # 메인 <-> 렌더러 간 안전한 IPC 브리지
├── config.json           # 실행 시 읽어 들이는 설정 파일
├── src/
│   ├── app/
│   │   └── page.tsx      # 대시보드 화면을 구성하는 Next.js 페이지
│   ├── components/       # 재사용 가능한 React UI 컴포넌트 모음
│   ├── hooks/            # 상태 관리와 로직을 담당하는 커스텀 훅
│   │   ├── useSerialManager.ts   # 포트 연결, 센서 데이터 수집, 밸브 제어 통합 관리
│   │   ├── useSequenceManager.ts # 자동 시퀀스 실행 및 로그 관리
│   │   ├── useSensorData.ts      # 시리얼 메시지 파싱 및 그래프 데이터 저장
│   │   └── useValveControl.ts    # 밸브 상태 변경 및 리미트 스위치 반영
│   ├── lib/            # 공용 라이브러리 코드
│   ├── types/          # TypeScript 타입 정의
│   └── utils/          # 유틸리티 함수
├── docs/               # 설계 문서와 참고 자료
├── package.json        # npm 스크립트 및 의존성 목록
└── ...
```

이 구조를 이해하면 원하는 위치의 코드를 빠르게 찾을 수 있습니다.

---

## GUI 코드 흐름 이해하기

초보자도 전체 프로그램의 흐름을 이해할 수 있도록 핵심 파일을 단계별로 설명합니다.

### 1. Electron 메인 프로세스 (`main.ts`)

- 애플리케이션 창을 생성하고 Next.js에서 빌드된 페이지를 로드합니다.
- Node.js의 `serialport` 라이브러리를 사용하여 실제 하드웨어와 통신합니다.
- IPC 채널을 통해 렌더러(React)와 메시지를 주고받습니다.

### 2. Preload 스크립트 (`preload.ts`)

- 메인 프로세스의 기능을 제한된 형태로 `window.electronAPI`에 노출합니다.
- 렌더러는 이 API를 사용해 시리얼 포트 목록 조회, 데이터 전송, 로그 시작/종료 등 안전한 작업만 수행할 수 있습니다.

### 3. React 페이지 (`src/app/page.tsx`)

- 대시보드 화면을 구성하는 최상위 컴포넌트입니다.
- 내부에서 여러 패널과 위젯을 불러와 배치하며, 각 패널은 **컴포넌트** 단위로 분리되어 있습니다.
- `useSerialManager`와 `useSequenceManager` 훅을 사용해 센서 값, 밸브 상태, 시퀀스 로그 등을 화면에 반영합니다.

### 4. 커스텀 훅

- `useSerialManager` : 포트 목록 조회, 연결 상태 관리, 수신 데이터 처리, 밸브 제어 등 대부분의 핵심 로직을 담당합니다.
- `useSequenceManager` : 사용자 정의 시퀀스를 순차적으로 실행하고 로그를 기록합니다.
- `useSensorData` : 시리얼로 들어오는 문자열을 파싱하여 센서 데이터와 그래프 데이터를 갱신합니다.
- `useValveControl` : 밸브의 개폐 명령을 전송하고 리미트 스위치 상태를 반영합니다.

### 5. 주요 UI 컴포넌트

- `Header` : 포트 선택, 연결/해제, 데이터 로깅 버튼, 연결 상태 표시
- `SensorPanel` : 압력/유량/온도 등의 실시간 수치를 숫자와 그래프로 표시
- `ValveDisplay` : 각 밸브의 현재 상태와 리미트 스위치 표시, 버튼 클릭으로 개폐 제어
- `SequencePanel` : 점화·퍼지·비상 정지 등 시퀀스 시작 버튼
- `DataChartPanel` : 선택된 센서의 시간에 따른 변화를 그래프로 표현
- `TerminalPanel` : 송수신 문자열과 시퀀스 로그를 스크롤 형태로 출력

이 흐름을 이해하면 새로운 센서나 패널을 추가하거나 기존 로직을 수정하기가 쉬워집니다.

---

## 설정 파일 상세 (`config.json`)

애플리케이션은 실행 시 `config.json`을 읽어 센서와 밸브 구성, 안전 한계값 등을 설정합니다. 기본 구조는 다음과 같습니다.

```json
{
  "serial": { "baudRate": 115200 },
  "maxChartDataPoints": 500,
  "pressureLimit": 50,
  "initialValves": [
    { "id": 0, "name": "Fuel Main", "state": "CLOSED" },
    { "id": 1, "name": "N2O Main", "state": "CLOSED" }
  ],
  "valveMappings": {
    "Fuel Main": { "servoIndex": 0 },
    "N2O Main": { "servoIndex": 1 }
  }
}
```

- `serial.baudRate` : 시리얼 포트 통신 속도. 펌웨어 설정과 반드시 일치해야 합니다.
- `maxChartDataPoints` : 그래프에 보존할 데이터 샘플의 최대 수.
- `pressureLimit` : 지정 값 이상이 되면 자동으로 비상 정지 시퀀스가 실행됩니다.
- `initialValves` : 앱 실행 시 표시할 밸브 목록과 초기 상태.
- `valveMappings` : UI에서 정의한 밸브 이름을 실제 서보 인덱스로 매핑합니다.

설정을 변경한 후에는 애플리케이션을 다시 시작하거나 `Ctrl+R`로 새로고침해야 적용됩니다. 새로운 밸브를 추가하려면 `initialValves`와 `valveMappings`에 항목을 추가하고, 필요하다면 하드웨어 펌웨어도 수정해야 합니다.

---

## 시퀀스 사용자 정의와 동작 방식

자동 시퀀스는 `src/hooks/useSequenceManager.ts`에서 정의됩니다. 이 훅은 다음과 같은 **단계 배열**을 순서대로 실행합니다.

```ts
interface SequenceStep {
  message: string;    // 로그에 표시할 메세지
  delay: number;      // 이전 단계 이후 대기 시간(ms)
  action?: () => void | Promise<void>; // 실행할 명령(선택 사항)
}
```

`handleSequence("Ignition Sequence")`와 같이 호출하면 내부의 `runSequence`가 각 단계를 `delay`만큼 기다린 뒤 `action`을 실행하고 `message`를 기록합니다. 시퀀스는 `AbortController`로 언제든 중단할 수 있습니다.

### 새로운 시퀀스 추가 예시

1. `useSequenceManager.ts`에서 `switch` 문에 새로운 `case`를 추가합니다.
2. 실행할 단계들을 배열로 작성합니다.

```ts
case 'Purge Sequence':
  void runSequence(
    'Purge Sequence',
    [
      { message: 'Opening purge valve...', delay: 0, action: () => sendCommand('V,1,O') },
      { message: 'Waiting 2 seconds', delay: 2000 },
      { message: 'Closing purge valve', delay: 0, action: () => sendCommand('V,1,C') }
    ],
    controller
  );
  break;
```

3. `src/components/dashboard/sequence-panel.tsx`에서 해당 시퀀스를 버튼으로 노출합니다.
4. 필요하다면 `config.json`에 관련 밸브 매핑을 추가합니다.

이 방식으로 점화 시간 조정, 밸브 조작 순서 변경 등 원하는 시나리오를 자유롭게 구성할 수 있습니다.

---

## 시리얼 통신 프로토콜

하드웨어와의 통신은 텍스트 기반이며, 다음 규칙을 따릅니다.

| 목적 | 형식 | 예시 |
| --- | --- | --- |
| **밸브 제어 명령** | `V,서보인덱스,상태` | `V,0,O` → 0번 서보를 Open |
| **센서 데이터 수신** | `키:값` 쌍을 콤마로 구분 | `PT1:123.4,PT2:125.0` |

- 밸브 상태는 `O`(Open) 또는 `C`(Close)로 표현합니다.
- 받은 문자열은 파싱되어 각 센서 값과 밸브 상태를 갱신합니다.
- 밸브와 서보 인덱스 매핑은 `config.json`에서 확인할 수 있습니다.

---

## 데이터 로깅

- 상단 `Start Logging` 버튼을 누르면 `Documents/rocket-log-YYYYMMDD-HHMMSS.csv` 형식의 파일이 생성됩니다.
- 로깅 중에는 수신한 센서 값이 실시간으로 CSV 파일에 추가됩니다.
- `Stop Logging`을 누르거나 프로그램을 종료하면 파일이 저장됩니다.
- 파일 생성에 실패하면 화면에 오류 메시지가 표시됩니다.

CSV 파일의 첫 줄(헤더)은 다음과 같습니다.

```
timestamp,PT1,PT2,PT3,PT4,Flow1,Flow2,Thermo
```

---

## UI 사용 방법

1. **시리얼 포트 선택 및 연결**
   - 앱 실행 후 상단 드롭다운에서 사용 가능한 포트를 선택합니다.
   - `Connect`를 클릭하면 연결 상태가 `Connected`로 바뀌고 센서 데이터 수신이 시작됩니다.

2. **센서 데이터 확인**
   - `Dashboard` 패널에서 각 센서 값을 숫자와 그래프로 동시에 확인할 수 있습니다.
   - 값이 비정상적으로 보이면 즉시 하드웨어를 점검하세요.

3. **밸브 제어**
   - `Valve Control & Status` 패널에서 각 밸브 버튼을 클릭해 개폐를 조작합니다.
   - 버튼 아래의 표시등은 리미트 스위치 상태를 나타냅니다.

4. **자동 시퀀스 실행**
   - `Sequence` 패널에서 점화(Ignition), 퍼지(Purge), 비상 정지(E‑Stop) 등을 선택해 실행합니다.
   - 진행 상황은 `Terminal` 패널에 시간 순으로 기록됩니다.

5. **로그 터미널 활용**
   - 모든 송수신 문자열과 시퀀스 로그가 `Terminal` 패널에 출력됩니다.
   - 문제가 발생하면 해당 로그를 확인하여 원인을 추적할 수 있습니다.

6. **데이터 로깅**
   - `Start Logging` 버튼으로 CSV 기록을 시작하고, 다시 눌러 종료합니다.

7. **화면 확대/축소**
   - `Ctrl` + 마우스 휠 또는 `Ctrl` + `=`/`-`/`0` 단축키로 화면 배율을 조정할 수 있습니다.

---

## 품질 검사와 빌드

코드를 수정했다면 다음 명령으로 품질을 확인하세요.

```bash
npm run lint         # ESLint 규칙 검사
npm run typecheck    # TypeScript 타입 검사
```

검사가 통과하면 `npm run build`로 배포용 파일을 생성할 수 있습니다. 시리얼 포트 모듈이 제대로 빌드되지 않으면 `npm run rebuild`를 실행해 다시 컴파일합니다.

---

## 문제 해결

- **시리얼 포트가 표시되지 않음**
  - 드라이버 설치 여부를 확인하고 다른 프로그램이 포트를 사용 중인지 체크합니다.
- **`npm run dev` 실행 시 오류**
  - Node.js와 npm 버전이 요구 사항을 만족하는지 확인한 뒤 `node_modules`와 `package-lock.json`을 삭제하고 다시 설치합니다.
- **로그 파일이 생성되지 않음**
  - 쓰기 권한이 있는 경로인지 확인하고 경로에 한글이나 공백이 없는지 점검합니다.
- **Electron 창이 열리지 않음**
  - Linux에서는 `DISPLAY` 환경 변수를 설정했는지, 보안 소프트웨어가 실행을 차단하지 않는지 확인하세요.

---

## 자주 묻는 질문

- **Q. 원격 제어나 네트워크 기능을 지원하나요?**
  - A. 현재 버전은 로컬 시리얼 연결만 지원하며 네트워크 제어는 제공하지 않습니다.
- **Q. 새로운 센서나 밸브를 추가하려면?**
  - A. `config.json`에 항목을 추가하고 관련 훅 및 컴포넌트를 수정한 뒤 다시 빌드합니다.
- **Q. 자동 시퀀스를 사용자 정의할 수 있나요?**
  - A. [`useSequenceManager`](#시퀀스-사용자-정의와-동작-방식)를 참고하여 원하는 단계 배열을 구성하면 커스텀 시나리오를 구현할 수 있습니다.

---

## 참고 문서 및 라이선스

- `docs/blueprint.md`에 초기 요구 사항과 디자인 가이드가 정리되어 있습니다.
- 소스 코드는 [MIT 라이선스](LICENSE)에 따라 자유롭게 사용할 수 있습니다. 단, 실사용에 따른 책임은 전적으로 사용자에게 있습니다.

---

이 README는 처음 프로젝트를 접하는 분도 **시리얼 통신 기반 GUI 제어 시스템**의 전체 흐름을 이해하고 수정·확장할 수 있도록 최대한 자세히 작성되었습니다. 문서를 참고하여 안전하고 효율적인 실험 환경을 구축하시기 바랍니다.

